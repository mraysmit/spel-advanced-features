package integration;

import engine.Rule;
import engine.RuleResult;
import org.springframework.expression.spel.support.StandardEvaluationContext;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import model.Customer;
import model.Product;
import model.Trade;
import engine.ExpressionEvaluatorService;
import service.LookupService;
import service.PricingService;
import engine.RuleEngineService;
import engine.TemplateProcessorService;
import data.MockDataSources;
import service.DataServiceManager;

/**
 * This class demonstrates advanced features of SpEL for dynamic evaluation.
 * It focuses on collection manipulation, array operations, and complex expressions.
 * 
 * This is a test/demo class that uses test data to demonstrate the rules engine functionality.
 */
public class SpelAdvancedFeaturesDemo {
    // Services
    private final ExpressionEvaluatorService evaluatorService;
    private final RuleEngineService ruleEngineService;
    private final TemplateProcessorService templateProcessorService;
    private final DataServiceManager dataServiceManager;

    /**
     * Constructor with dependency injection.
     * 
     * @param evaluatorService The expression evaluator service
     * @param ruleEngineService The rule engine service
     * @param templateProcessorService The template processor service
     */
    public SpelAdvancedFeaturesDemo(
            ExpressionEvaluatorService evaluatorService,
            RuleEngineService ruleEngineService,
            TemplateProcessorService templateProcessorService) {
        this.evaluatorService = evaluatorService;
        this.ruleEngineService = ruleEngineService;
        this.templateProcessorService = templateProcessorService;

        // Initialize DataServiceManager with mock data
        this.dataServiceManager = new DataServiceManager();
        this.dataServiceManager.initializeWithMockData();
    }

    public static void main(String[] args) {
        // Create services
        ExpressionEvaluatorService evaluatorService = new ExpressionEvaluatorService();
        RuleEngineService ruleEngineService = new RuleEngineService(evaluatorService);
        TemplateProcessorService templateProcessorService = new TemplateProcessorService(evaluatorService);
        PricingService pricingService = new PricingService();

        // Create main class with injected services
        SpelAdvancedFeaturesDemo spelAdvancedFeaturesDemo = new SpelAdvancedFeaturesDemo(
            evaluatorService,
            ruleEngineService,
            templateProcessorService
        );

        // Example 1: Collection and array operations
        spelAdvancedFeaturesDemo.demonstrateCollectionOperations();

        // Example 2: Advanced rule engine with collection filtering
        spelAdvancedFeaturesDemo.demonstrateAdvancedRuleEngine();

        // Example 3: Dynamic method resolution and execution
        spelAdvancedFeaturesDemo.demonstrateDynamicMethodExecution(pricingService);

        // Example 4: Template expressions with placeholders
        spelAdvancedFeaturesDemo.demonstrateTemplateExpressions();

        // Example 5: XML template expressions with placeholders
        spelAdvancedFeaturesDemo.demonstrateXmlTemplateExpressions();

        // Example 6: JSON template expressions with placeholders
        spelAdvancedFeaturesDemo.demonstrateJsonTemplateExpressions();

        // Example 7: Dynamic lookup service
        spelAdvancedFeaturesDemo.demonstrateDynamicLookupService();
    }

    /**
     * Demonstrates collection operations using SpEL.
     */
    private void demonstrateCollectionOperations() {
        System.out.println("\n=== Financial Instrument Collection Operations ===");

        StandardEvaluationContext context = new StandardEvaluationContext();

        // Get products from data service
        List<Product> products = dataServiceManager.requestData("products");
        context.setVariable("products", products);

        // Collection selection - filter fixed income products
        RuleResult result1 = evaluatorService.evaluateWithResult("#products.?[category == 'FixedIncome']", context, List.class);
        System.out.println("Rule result: " + (result1.isTriggered() ? "Triggered" : "Not triggered"));

        // Collection projection - get all product names
        RuleResult result2 = evaluatorService.evaluateWithResult("#products.![name]", context, List.class);
        System.out.println("Rule result: " + (result2.isTriggered() ? "Triggered" : "Not triggered"));

        // Combining selection and projection - names of equity products
        RuleResult result3 = evaluatorService.evaluateWithResult("#products.?[category == 'Equity'].![name]", context, List.class);
        System.out.println("Rule result: " + (result3.isTriggered() ? "Triggered" : "Not triggered"));

        // Aggregation - average price of all products
        double totalPrice = 0;
        for (Product product : products) {
            totalPrice += product.getPrice();
        }
        System.out.println("Expression: Average price of all products => " + (totalPrice / products.size()));

        // Aggregation with filtering - sum of fixed income prices
        double fixedIncomeTotal = 0;
        for (Product product : products) {
            if ("FixedIncome".equals(product.getCategory())) {
                fixedIncomeTotal += product.getPrice();
            }
        }
        System.out.println("Expression: Sum of fixed income prices => " + fixedIncomeTotal);

        // First and last elements
        // Add price threshold as a parameter
        context.setVariable("priceThreshold", 500.0);
        RuleResult result4 = evaluatorService.evaluateWithResult("#products.^[price > #priceThreshold].name", context, String.class); // First product over price threshold
        System.out.println("Rule result: " + (result4.isTriggered() ? "Triggered" : "Not triggered"));

        RuleResult result5 = evaluatorService.evaluateWithResult("#products.$[price < 200].name", context, String.class); // Last product under $200
        System.out.println("Rule result: " + (result5.isTriggered() ? "Triggered" : "Not triggered"));
    }

    /**
     * Demonstrates advanced rule engine with collection filtering.
     */
    private void demonstrateAdvancedRuleEngine() {
        System.out.println("\n=== Financial Services Rule Engine with Investment Filtering ===");

        // Get inventory and customer from data service
        List<Product> inventory = dataServiceManager.requestData("inventory");
        Customer customer = dataServiceManager.requestData("customer");

        // Create context with variables
        StandardEvaluationContext context = new StandardEvaluationContext();
        context.setVariable("inventory", inventory);
        context.setVariable("customer", customer);

        // Define complex rules
        List<Rule> rules = new ArrayList<>();

        // Add rules from rule definition service
        rules.add(DemoRuleConfiguration.createInvestmentRecommendationsRule());
        rules.add(DemoRuleConfiguration.createGoldTierInvestorOffersRule());
        rules.add(DemoRuleConfiguration.createLowCostInvestmentOptionsRule());

        // Evaluate all rules
        ruleEngineService.evaluateRules(rules, context);
    }

    /**
     * Demonstrates dynamic method resolution and execution.
     * 
     * @param pricingService The pricing service to use
     */
    private void demonstrateDynamicMethodExecution(PricingService pricingService) {
        System.out.println("\n=== Dynamic Financial Pricing Method Resolution ===");

        StandardEvaluationContext context = new StandardEvaluationContext();
        context.setVariable("service", pricingService);
        context.setVariable("basePrice", 100.0);

        // Define different financial pricing strategies as expressions
        Map<String, String> pricingStrategies = new HashMap<>();
        pricingStrategies.put("market", "#service.calculateStandardPrice(#basePrice)");
        pricingStrategies.put("premium", "#service.calculatePremiumPrice(#basePrice)");
        pricingStrategies.put("discount", "#service.calculateSalePrice(#basePrice)");
        pricingStrategies.put("liquidation", "#service.calculateClearancePrice(#basePrice)");

        // Dynamically execute different pricing methods based on strategy
        for (Map.Entry<String, String> strategy : pricingStrategies.entrySet()) {
            System.out.println("Strategy: " + strategy.getKey());
            RuleResult result = evaluatorService.evaluateWithResult(strategy.getValue(), context, Double.class);
            System.out.println("Rule result: " + (result.isTriggered() ? "Triggered" : "Not triggered"));
        }

        // Dynamic pricing method selection based on instrument value
        String dynamicMethodExpression = 
            "#basePrice > 50 ? " +
            "#service.calculatePremiumPrice(#basePrice) : " +
            "#service.calculateSalePrice(#basePrice)";

        System.out.println("\nDynamic pricing method selection based on instrument value:");
        RuleResult result = evaluatorService.evaluateWithResult(dynamicMethodExpression, context, Double.class);
        System.out.println("Rule result: " + (result.isTriggered() ? "Triggered" : "Not triggered"));
    }

    /**
     * Demonstrates template expressions with placeholders.
     */
    private void demonstrateTemplateExpressions() {
        System.out.println("\n=== Financial Services Communication Templates ===");

        // Create a context with variables for financial services
        StandardEvaluationContext context = new StandardEvaluationContext();
        context.setVariable("customer", dataServiceManager.requestData("templateCustomer"));
        context.setVariable("orderTotal", 350.0);
        context.setVariable("tradingFee", 15.0);

        // Template with placeholders for investment confirmation
        String emailTemplate = 
            "Dear #{#customer.name},\n\n" +
            "Thank you for your investment. Your #{#customer.membershipLevel} investor status entitles you to " +
            "#{#customer.membershipLevel == 'Gold' ? '15%' : (#customer.membershipLevel == 'Silver' ? '10%' : '5%')} reduced fees.\n\n" +
            "Investment amount: $#{#orderTotal}\n" +
            "Trading fee: $#{#tradingFee}\n" +
            "Fee discount: $#{#customer.membershipLevel == 'Gold' ? #orderTotal * 0.15 : " +
                        "(#customer.membershipLevel == 'Silver' ? #orderTotal * 0.1 : #orderTotal * 0.05)}\n" +
            "Final investment total: $#{#orderTotal + #tradingFee - " +
                        "(#customer.membershipLevel == 'Gold' ? #orderTotal * 0.15 : " +
                        "(#customer.membershipLevel == 'Silver' ? #orderTotal * 0.1 : #orderTotal * 0.05))}\n\n" +
            "#{#customer.age > 60 ? 'As a senior investor, you will receive our retirement planning guide next week.' : ''}";

        // Process the template by replacing all placeholders with evaluated expressions
        String processedEmail = templateProcessorService.processTemplate(emailTemplate, context);
        System.out.println(processedEmail);
    }

    /**
     * Demonstrates XML template expressions with placeholders.
     */
    private void demonstrateXmlTemplateExpressions() {
        System.out.println("\n=== XML Financial Services Communication Templates ===");

        // Create a context with variables for financial services
        StandardEvaluationContext context = new StandardEvaluationContext();
        context.setVariable("customer", dataServiceManager.requestData("templateCustomer"));
        context.setVariable("orderTotal", 350.0);
        context.setVariable("tradingFee", 15.0);

        // XML template with placeholders for investment confirmation
        String xmlTemplate = 
            "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" +
            "<InvestmentConfirmation>\n" +
            "    <Customer>\n" +
            "        <Name>#{#customer.name}</Name>\n" +
            "        <Age>#{#customer.age}</Age>\n" +
            "        <MembershipLevel>#{#customer.membershipLevel}</MembershipLevel>\n" +
            "    </Customer>\n" +
            "    <Investment>\n" +
            "        <Amount>#{#orderTotal}</Amount>\n" +
            "        <TradingFee>#{#tradingFee}</TradingFee>\n" +
            "        <Discount>#{#customer.membershipLevel == 'Gold' ? #orderTotal * 0.15 : " +
                        "(#customer.membershipLevel == 'Silver' ? #orderTotal * 0.1 : #orderTotal * 0.05)}</Discount>\n" +
            "        <Total>#{#orderTotal + #tradingFee - " +
                        "(#customer.membershipLevel == 'Gold' ? #orderTotal * 0.15 : " +
                        "(#customer.membershipLevel == 'Silver' ? #orderTotal * 0.1 : #orderTotal * 0.05))}</Total>\n" +
            "    </Investment>\n" +
            "    <SpecialOffers>\n" +
            "        #{#customer.age > 60 ? '<Offer>Senior Investor Retirement Planning Guide</Offer>' : ''}\n" +
            "        #{#customer.membershipLevel == 'Gold' ? '<Offer>Premium Investment Opportunities</Offer>' : ''}\n" +
            "    </SpecialOffers>\n" +
            "</InvestmentConfirmation>";

        // Process the XML template by replacing all placeholders with evaluated expressions
        String processedXml = templateProcessorService.processXmlTemplate(xmlTemplate, context);
        System.out.println(processedXml);
    }

    /**
     * Demonstrates JSON template expressions with placeholders.
     */
    private void demonstrateJsonTemplateExpressions() {
        System.out.println("\n=== JSON Financial Services Communication Templates ===");

        // Create a context with variables for financial services
        StandardEvaluationContext context = new StandardEvaluationContext();
        context.setVariable("customer", dataServiceManager.requestData("templateCustomer"));
        context.setVariable("orderTotal", 350.0);
        context.setVariable("tradingFee", 15.0);

        // JSON template with placeholders for investment confirmation
        String jsonTemplate = 
            "{\n" +
            "  \"investmentConfirmation\": {\n" +
            "    \"customer\": {\n" +
            "      \"name\": \"#{#customer.name}\",\n" +
            "      \"age\": #{#customer.age},\n" +
            "      \"membershipLevel\": \"#{#customer.membershipLevel}\"\n" +
            "    },\n" +
            "    \"investment\": {\n" +
            "      \"amount\": #{#orderTotal},\n" +
            "      \"tradingFee\": #{#tradingFee},\n" +
            "      \"discount\": #{#customer.membershipLevel == 'Gold' ? #orderTotal * 0.15 : " +
                        "(#customer.membershipLevel == 'Silver' ? #orderTotal * 0.1 : #orderTotal * 0.05)},\n" +
            "      \"total\": #{#orderTotal + #tradingFee - " +
                        "(#customer.membershipLevel == 'Gold' ? #orderTotal * 0.15 : " +
                        "(#customer.membershipLevel == 'Silver' ? #orderTotal * 0.1 : #orderTotal * 0.05))}\n" +
            "    },\n" +
            "    \"specialOffers\": [\n" +
            "      #{#customer.age > 60 ? '\"Senior Investor Retirement Planning Guide\"' : 'null'}#{#customer.age > 60 && #customer.membershipLevel == 'Gold' ? ',' : ''},\n" +
            "      #{#customer.membershipLevel == 'Gold' ? '\"Premium Investment Opportunities\"' : 'null'}\n" +
            "    ]\n" +
            "  }\n" +
            "}";

        // Process the JSON template by replacing all placeholders with evaluated expressions
        String processedJson = templateProcessorService.processJsonTemplate(jsonTemplate, context);
        System.out.println(processedJson);
    }

    /**
     * Demonstrates dynamic lookup service.
     */
    private void demonstrateDynamicLookupService() {
        System.out.println("\n=== Dynamic Lookup Service ===");

        // Create lookup services and source records
        List<LookupService> lookupServices = dataServiceManager.requestData("lookupServices");
        List<Trade> sourceTrades = dataServiceManager.requestData("sourceRecords");

        // Create context with variables
        StandardEvaluationContext context = new StandardEvaluationContext();
        context.setVariable("lookupServices", lookupServices);
        context.setVariable("sourceRecords", sourceTrades);

        // Example 1: Find all records that match any lookup service
        System.out.println("\nRecords matching any lookup service:");
        List<Trade> matchingTrades = dataServiceManager.requestData("matchingRecords", sourceTrades, lookupServices);
        System.out.println("Result: " + matchingTrades);

        // Example 2: Find all records that don't match any lookup service
        System.out.println("\nRecords not matching any lookup service:");
        List<Trade> nonMatchingTrades = dataServiceManager.requestData("nonMatchingRecords", sourceTrades, lookupServices);
        System.out.println("Result: " + nonMatchingTrades);

        // Example 3: Group records by matching lookup service
        System.out.println("\nRecords grouped by matching lookup service:");
        for (LookupService lookupService : lookupServices) {
            context.setVariable("currentLookup", lookupService);
            String matchSpecificExpression = "#sourceRecords.?[" +
                "#currentLookup.lookupValues.contains(value)" +
            "]";
            RuleResult result = evaluatorService.evaluateWithResult(matchSpecificExpression, context, List.class);
            List<Trade> specificMatches = evaluatorService.evaluateQuietly(matchSpecificExpression, context, List.class);
            System.out.println(lookupService.getName() + " matches: " + specificMatches);
            System.out.println("Rule result: " + (result.isTriggered() ? "Triggered" : "Not triggered"));
        }

        // Example 4: Dynamic matching with complex conditions for financial trades
        System.out.println("\nDynamic matching with complex conditions for financial trades:");
        String complexMatchExpression = "#sourceRecords.?[" +
            "(category == 'InstrumentType' && #lookupServices[0].lookupValues.contains(value)) || " +
            "(category == 'Market' && #lookupServices[1].lookupValues.contains(value)) || " +
            "(category == 'TradeStatus' && #lookupServices[2].lookupValues.contains(value))" +
        "]";
        RuleResult result = evaluatorService.evaluateWithResult(complexMatchExpression, context, List.class);
        System.out.println("Rule result: " + (result.isTriggered() ? "Triggered" : "Not triggered"));
    }
}